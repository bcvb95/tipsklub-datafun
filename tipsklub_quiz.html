<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Tipsklub 2025 - Quiz</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
*{ margin:0; padding:0; box-sizing:border-box; }
body {
    background: #0f172a;
    color: #f1f5f9;
    font-family: 'Inter', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    min-height: 100dvh;
    overflow-x: hidden;
}
.screen { display:none; min-height:100dvh; padding:20px; }
.screen.active { display:flex; flex-direction:column; align-items:center; justify-content:center; }

/* Landing */
.landing-title { font-size:2rem; font-weight:900; text-align:center; margin-bottom:8px; }
.landing-sub { color:#94a3b8; text-align:center; margin-bottom:32px; }
.btn { display:block; width:100%; max-width:320px; padding:16px; border:none; border-radius:12px;
        font-family:inherit; font-size:1.1rem; font-weight:700; cursor:pointer;
        transition:transform .1s, opacity .1s; margin:6px auto; }
.btn:active { transform:scale(0.97); opacity:.9; }
.btn-host { background:#2563eb; color:#fff; }
.btn-join { background:#16a34a; color:#fff; }
.btn-reveal { background:#d97706; color:#fff; }
.btn-next { background:#2563eb; color:#fff; }
.btn-disabled { background:#334155; color:#64748b; pointer-events:none; }

/* Host lobby */
.room-code { font-size:3rem; font-weight:900; letter-spacing:.3em; color:#2563eb;
              background:#1e293b; border-radius:16px; padding:16px 32px; margin:16px 0; text-align:center; }
#qrCanvas { margin:12px auto; display:block; border-radius:12px; background:#fff; padding:8px; }
.player-list { width:100%; max-width:320px; margin:16px 0; }
.player-chip { background:#1e293b; border-radius:8px; padding:10px 16px; margin:4px 0;
                font-weight:600; display:flex; align-items:center; gap:8px; }
.player-dot { width:10px; height:10px; border-radius:50%; }

/* Join */
.input { width:100%; max-width:320px; padding:14px 16px; border:2px solid #334155; border-radius:12px;
          background:#1e293b; color:#f1f5f9; font-family:inherit; font-size:1rem; font-weight:600;
          text-align:center; margin:6px auto; display:block; }
.input::placeholder { color:#64748b; }
.input:focus { outline:none; border-color:#2563eb; }
.input.code { font-size:1.8rem; letter-spacing:.3em; text-transform:uppercase; }
.waiting { color:#94a3b8; font-size:1rem; margin-top:16px; }
.waiting .dot { animation:blink 1.4s infinite; }
@keyframes blink { 0%,100%{ opacity:.2; } 50%{ opacity:1; } }

/* Question (Host) */
.q-num { font-size:.8rem; color:#64748b; text-transform:uppercase; letter-spacing:.1em; margin-bottom:8px; }
.q-text { font-size:1.3rem; font-weight:700; text-align:center; margin-bottom:24px; line-height:1.4; }
.host-options { width:100%; max-width:500px; }
.host-opt { background:#1e293b; border-radius:10px; padding:12px 16px; margin:6px 0;
             display:flex; justify-content:space-between; align-items:center; font-weight:600; }
.host-opt .count { background:#334155; border-radius:6px; padding:4px 10px; font-size:.9rem; min-width:30px; text-align:center; }
.host-opt.correct { background:#16a34a33; border:2px solid #16a34a; }
.host-opt.wrong { background:#dc262633; border:2px solid #dc2626; opacity:.6; }
.vote-names { font-size:.7rem; color:#94a3b8; margin-top:4px; }

/* Question (Player) */
.answer-btn { display:block; width:100%; max-width:400px; padding:18px 16px; margin:6px auto;
               border:2px solid #334155; border-radius:12px; background:#1e293b; color:#f1f5f9;
               font-family:inherit; font-size:1rem; font-weight:600; cursor:pointer;
               transition:transform .1s, border-color .15s; }
.answer-btn:active { transform:scale(0.97); }
.answer-btn.selected { border-color:#2563eb; background:#2563eb22; }
.answer-btn.correct-pick { border-color:#16a34a; background:#16a34a33; }
.answer-btn.wrong-pick { border-color:#dc2626; background:#dc262633; }
.answer-btn:disabled { cursor:default; opacity:.7; }

/* Feedback */
.feedback { font-size:1.5rem; font-weight:900; text-align:center; margin:16px 0; }
.feedback.right { color:#16a34a; }
.feedback.wrong { color:#dc2626; }
.score-display { color:#94a3b8; font-size:1rem; text-align:center; }

/* Chart reveal */
.chart-container { width:100%; max-width:500px; background:#fff; border-radius:12px;
                    padding:16px; margin:16px 0; }
.chart-container canvas { width:100%!important; }
.reveal-text { font-size:1rem; font-weight:600; color:#94a3b8; text-align:center; margin:8px 0; }

.ranking-list { width:100%; max-width:400px; margin:12px 0; }
.rank-row { display:flex; align-items:center; padding:8px 12px; margin:3px 0;
             background:#1e293b; border-radius:8px; font-size:.9rem; }
.rank-row.gold { background:#fbbf2418; border:1px solid #fbbf2444; }
.rank-pos { width:24px; font-weight:900; color:#64748b; }
.rank-row.gold .rank-pos { color:#fbbf24; }
.rank-name { flex:1; font-weight:600; }
.rank-val { font-weight:700; color:#94a3b8; }

/* Quick stats reveal */
.qs-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; width:100%; max-width:400px; margin:16px 0; }
.qs-item { background:#1e293b; border-radius:12px; padding:16px; text-align:center; }
.qs-item .val { font-size:1.4rem; font-weight:700; color:#2563eb; }
.qs-item .lbl { font-size:.7rem; color:#64748b; text-transform:uppercase; margin-top:4px; }

/* Scoreboard */
.scoreboard { width:100%; max-width:400px; margin:16px 0; }
.sb-row { display:flex; align-items:center; padding:14px 16px; margin:4px 0;
           background:#1e293b; border-radius:10px; }
.sb-rank { font-size:1.5rem; font-weight:900; width:36px; text-align:center; }
.sb-rank.gold { color:#fbbf24; }
.sb-rank.silver { color:#94a3b8; }
.sb-rank.bronze { color:#cd7f32; }
.sb-name { flex:1; font-weight:700; font-size:1.1rem; margin-left:12px; }
.sb-score { font-weight:700; font-size:1.1rem; color:#2563eb; }
.sb-correct { font-size:.75rem; color:#64748b; margin-left:4px; }
.sb-answers { background:#1e293b; border-radius:0 0 10px 10px; margin:-4px 0 4px; padding:4px 12px 8px; }
.sb-answer { font-size:.8rem; padding:3px 0; color:#94a3b8; }
.sb-aq { color:#64748b; font-weight:600; margin:0 4px; }

/* Status bar */
.status-bar { position:fixed; top:0; left:0; right:0; background:#1e293b; border-bottom:1px solid #334155;
               padding:8px 16px; display:flex; justify-content:space-between; align-items:center;
               font-size:.75rem; color:#94a3b8; z-index:100; }
.status-bar .room { font-weight:700; color:#2563eb; }

/* Error */
.error { color:#dc2626; font-size:.85rem; text-align:center; margin:8px 0; }

@media(max-width:400px) {
    .landing-title { font-size:1.5rem; }
    .q-text { font-size:1.1rem; }
    .room-code { font-size:2.2rem; padding:12px 20px; }
}

/* Progress bar */
.progress-track { position:fixed; top:0; left:0; right:0; height:4px; background:#0f172a; z-index:200; }
.progress-fill { height:100%; background:linear-gradient(90deg, #2563eb, #7c3aed); transition:width 0.6s ease; width:0%; }

/* Timer */
.timer-container { width:100%; max-width:500px; height:8px; background:#334155; border-radius:4px; margin:8px 0 16px; overflow:hidden; }
.timer-bar { height:100%; width:100%; border-radius:4px; background:linear-gradient(90deg, #dc2626, #d97706, #16a34a); }
.timer-text { font-size:2.8rem; font-weight:900; color:#475569; text-align:center; margin:4px 0; font-variant-numeric:tabular-nums; line-height:1; }
.timer-text.urgent { color:#dc2626; animation:pulse 0.5s infinite; }
@keyframes pulse { 0%,100%{ transform:scale(1); } 50%{ transform:scale(1.15); } }

/* Screen transitions */
.screen.active { animation:fadeSlideIn 0.3s ease; }
@keyframes fadeSlideIn { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }

/* Colored answer options (Kahoot-style) */
.answer-btn:nth-child(1), .host-opt:nth-child(1) { border-left:5px solid #dc2626; }
.answer-btn:nth-child(2), .host-opt:nth-child(2) { border-left:5px solid #2563eb; }
.answer-btn:nth-child(3), .host-opt:nth-child(3) { border-left:5px solid #d97706; }
.answer-btn:nth-child(4), .host-opt:nth-child(4) { border-left:5px solid #16a34a; }
.answer-btn:nth-child(5), .host-opt:nth-child(5) { border-left:5px solid #7c3aed; }

/* Score popup */
.score-popup { position:fixed; top:40%; left:50%; transform:translate(-50%,-50%); font-size:3rem; font-weight:900;
                color:#fbbf24; text-shadow:0 2px 12px rgba(0,0,0,.5); pointer-events:none; z-index:300;
                animation:scoreFloat 1.8s ease forwards; }
@keyframes scoreFloat { 0%{ opacity:1; transform:translate(-50%,-50%) scale(0.5); }
                         25%{ opacity:1; transform:translate(-50%,-50%) scale(1.3); }
                         100%{ opacity:0; transform:translate(-50%,-120%) scale(1); } }

/* Confetti canvas */
#confettiCanvas { position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:250; display:none; }

/* Mini scoreboard on reveal */
.mini-sb { width:100%; max-width:400px; margin:20px 0 8px; }
.mini-sb-title { text-align:center; font-size:.75rem; color:#64748b; text-transform:uppercase; letter-spacing:.1em; margin-bottom:8px; }
.mini-sb-row { display:flex; align-items:center; padding:10px 14px; margin:3px 0; background:#1e293b; border-radius:8px; }
.mini-sb-pos { width:28px; font-weight:900; color:#64748b; font-size:.9rem; }
.mini-sb-pos.first { color:#fbbf24; }
.mini-sb-name { flex:1; font-weight:600; }
.mini-sb-score { font-weight:700; color:#2563eb; font-size:1.05rem; }
.mini-sb-earned { font-size:.75rem; color:#16a34a; margin-left:6px; font-weight:600; }

/* Enhanced player feedback */
.feedback-detail { color:#94a3b8; font-size:.9rem; text-align:center; margin:8px 0; }
.feedback-correct-answer { color:#16a34a; font-weight:700; }
.feedback-earned { font-size:2rem; font-weight:900; color:#fbbf24; text-align:center; margin:8px 0; animation:fadeSlideIn 0.4s ease; }

/* Final scoreboard animations */
.sb-row { animation:slideInRow 0.5s ease both; }
@keyframes slideInRow { from { opacity:0; transform:translateY(15px); } to { opacity:1; transform:translateY(0); } }
.winner-banner { font-size:1.5rem; font-weight:900; color:#fbbf24; text-align:center; margin-bottom:20px;
                  animation:winnerGlow 2s ease infinite; }
@keyframes winnerGlow { 0%,100%{ text-shadow:0 0 10px rgba(251,191,36,.2); } 50%{ text-shadow:0 0 25px rgba(251,191,36,.6); } }

/* Locked answer buttons */
.answer-btn.locked { opacity:.5; pointer-events:none; }
</style>
</head>
<body>
<div class="progress-track"><div class="progress-fill" id="progressBar"></div></div>
<canvas id="confettiCanvas"></canvas>

<!-- Screen: Landing -->
<div id="screenLanding" class="screen active">
    <div class="landing-title">Tipsklub 2025</div>
    <div class="landing-sub">Interaktiv Quiz</div>
    <div class="landing-sub" style="margin-bottom:8px;">29/04/2025 — 24/01/2026 &middot; 5 spillere &middot; 31 uger &middot; 110 bets</div>
    <button class="btn btn-host" onclick="startHost()">Vært (Host)</button>
    <button class="btn btn-join" onclick="showJoin()">Deltag (Join)</button>
</div>

<!-- Screen: Host Lobby -->
<div id="screenHostLobby" class="screen">
    <div class="q-num">Del denne kode</div>
    <div class="room-code" id="roomCodeDisplay"></div>
    <canvas id="qrCanvas" width="180" height="180"></canvas>
    <div class="q-num" style="margin-top:12px;">Spillere</div>
    <div class="player-list" id="playerList"></div>
    <button class="btn btn-host" id="btnStartQuiz" onclick="hostStartQuiz()">Start Quiz</button>
</div>

<!-- Screen: Join -->
<div id="screenJoin" class="screen">
    <div class="q-text">Indtast kode</div>
    <input class="input code" id="inputCode" maxlength="4" placeholder="ABCD" autocomplete="off" autocapitalize="characters">
    <input class="input" id="inputName" placeholder="Dit navn" autocomplete="off">
    <button class="btn btn-join" onclick="joinRoom()">Tilslut</button>
    <div class="error" id="joinError"></div>
</div>

<!-- Screen: Player Waiting -->
<div id="screenPlayerWait" class="screen">
    <div class="q-text">Du er med!</div>
    <div class="waiting">Venter på at quizzen starter<span class="dot">...</span></div>
</div>

<!-- Screen: Host Question -->
<div id="screenHostQ" class="screen">
    <div class="status-bar">
        <span>Kode: <span class="room" id="statusRoom"></span></span>
        <span id="statusQ"></span>
    </div>
    <div style="margin-top:48px;width:100%;max-width:500px;display:flex;flex-direction:column;align-items:center;">
        <div class="q-num" id="hostQNum"></div>
        <div class="q-text" id="hostQText"></div>
        <div class="timer-text" id="hostTimerText"></div>
        <div class="timer-container"><div class="timer-bar" id="hostTimerBar"></div></div>
        <div class="host-options" id="hostOptions"></div>
        <div style="text-align:center;margin-top:12px;color:#64748b;font-size:.85rem;" id="hostVoteCount"></div>
        <button class="btn btn-reveal" id="btnReveal" onclick="hostReveal()" style="margin-top:16px;">Vis Svar</button>
    </div>
</div>

<!-- Screen: Host Reveal -->
<div id="screenHostReveal" class="screen">
    <div class="status-bar">
        <span>Kode: <span class="room" id="statusRoom2"></span></span>
        <span id="statusQ2"></span>
    </div>
    <div style="margin-top:48px;width:100%;max-width:500px;display:flex;flex-direction:column;align-items:center;">
        <div class="reveal-text" id="revealText"></div>
        <div class="ranking-list" id="rankingList"></div>
        <div class="chart-container" id="chartRevealContainer">
            <canvas id="chartReveal" height="200"></canvas>
        </div>
        <div class="qs-grid" id="quickStatsReveal" style="display:none;"></div>
        <div class="mini-sb" id="miniScoreboard"></div>
        <button class="btn btn-next" id="btnNext" onclick="hostNextQuestion()" style="margin-top:16px;">Næste Spørgsmål</button>
    </div>
</div>

<!-- Screen: Player Question -->
<div id="screenPlayerQ" class="screen">
    <div style="width:100%;max-width:400px;display:flex;flex-direction:column;align-items:center;">
        <div class="q-num" id="playerQNum"></div>
        <div class="q-text" id="playerQText"></div>
        <div class="timer-text" id="playerTimerText"></div>
        <div class="timer-container"><div class="timer-bar" id="playerTimerBar"></div></div>
        <div id="playerOptions" style="width:100%;"></div>
    </div>
</div>

<!-- Screen: Player Feedback -->
<div id="screenPlayerFeedback" class="screen">
    <div class="feedback" id="playerFeedback"></div>
    <div class="feedback-detail" id="playerFeedbackDetail"></div>
    <div class="feedback-earned" id="playerEarned"></div>
    <div class="score-display" id="playerScore"></div>
    <div class="waiting" style="margin-top:24px;">Venter på næste spørgsmål<span class="dot">...</span></div>
</div>

<!-- Screen: Halftime (Host) -->
<div id="screenHalftime" class="screen">
    <div class="landing-title" style="margin-bottom:4px;">Halvleg!</div>
    <div class="landing-sub">Halvvejs — her er stillingen</div>
    <div class="scoreboard" id="halftimeScoreboard"></div>
    <button class="btn btn-host" id="btnHalftimeContinue" onclick="halftimeContinue()" style="margin-top:24px;">Videre til 2. halvleg</button>
</div>

<!-- Screen: Halftime (Player) -->
<div id="screenPlayerHalftime" class="screen">
    <div class="landing-title" style="margin-bottom:4px;">Halvleg!</div>
    <div class="landing-sub">Halvvejs — her er stillingen</div>
    <div class="scoreboard" id="playerHalftimeScoreboard"></div>
    <div class="waiting" style="margin-top:24px;">Venter på 2. halvleg<span class="dot">...</span></div>
</div>

<!-- Screen: Final Scoreboard -->
<div id="screenScoreboard" class="screen">
    <div class="landing-title" style="margin-bottom:4px;">Resultater</div>
    <div class="winner-banner" id="winnerBanner"></div>
    <div class="scoreboard" id="scoreboard"></div>
    <button class="btn btn-host" onclick="location.reload()" style="margin-top:24px;">Spil Igen</button>
</div>

<script>
// ── Data (embedded at build time) ──
const QUESTIONS = [{"question": "Hvem ramte den bedste enkeluge i hele 2025?", "options": ["Jonas", "Gustav", "Nikolaj", "Nixon", "Bjørn"], "correct": 2, "reveal": "Nikolaj hamrede +590 kr hjem på en enkelt uge! (uge 2025-W35)", "chartId": "bestWeeks", "ranking": [{"name": "Nikolaj", "value": "+590 kr"}, {"name": "Jonas", "value": "+440 kr"}, {"name": "Nixon", "value": "+375 kr"}, {"name": "Bjørn", "value": "+200 kr"}, {"name": "Gustav", "value": "+86 kr"}]}, {"question": "Hvilken måned var bedst for klubben?", "options": ["Okt", "Jan", "Dec", "Aug"], "correct": 3, "reveal": "Aug var guld! +687 kr profit for klubben", "chartId": "monthly", "ranking": [{"name": "Aug", "value": "+687 kr"}, {"name": "Dec", "value": "+613 kr"}, {"name": "Sep", "value": "+152 kr"}, {"name": "Okt", "value": "+70 kr"}, {"name": "Jan", "value": "+30 kr"}, {"name": "Maj", "value": "-2 kr"}, {"name": "Apr", "value": "-182 kr"}, {"name": "Nov", "value": "-525 kr"}]}, {"question": "Hvem er den største Odds-Junkie? (højeste gns. odds)", "options": ["Gustav", "Nikolaj", "Jonas", "Bjørn", "Nixon"], "correct": 0, "reveal": "Gustav lever farligt — gns. odds 5.01!", "chartId": "odds", "ranking": [{"name": "Gustav", "value": "5.01"}, {"name": "Nixon", "value": "3.62"}, {"name": "Nikolaj", "value": "3.52"}, {"name": "Jonas", "value": "3.29"}, {"name": "Bjørn", "value": "3.14"}]}, {"question": "Hvilken ugedag blev der spillet mest på?", "options": ["Tor", "Fre", "Lør", "Tir"], "correct": 2, "reveal": "Lør er den hellige spilledag — 36 bets!", "chartId": "weekdayTotal", "ranking": [{"name": "Lør", "value": "36 bets"}, {"name": "Søn", "value": "17 bets"}, {"name": "Ons", "value": "16 bets"}, {"name": "Tir", "value": "15 bets"}, {"name": "Fre", "value": "10 bets"}, {"name": "Man", "value": "9 bets"}, {"name": "Tor", "value": "7 bets"}]}, {"question": "Hvem lavede flest individuelle bets?", "options": ["Jonas", "Bjørn", "Gustav", "Nixon", "Nikolaj"], "correct": 1, "reveal": "Bjørn fyrede 23 bets af — ingen holder igen!", "chartId": "betsPerPlayer", "ranking": [{"name": "Bjørn", "value": "23 bets"}, {"name": "Nikolaj", "value": "22 bets"}, {"name": "Jonas", "value": "22 bets"}, {"name": "Gustav", "value": "22 bets"}, {"name": "Nixon", "value": "21 bets"}]}, {"question": "Hvilken af vores top-ligaer gav mest profit?", "options": ["English Premier League", "UEFA Champions League", "Danish Superliga", "Serie A"], "correct": 1, "reveal": "UEFA Champions League leverede +285 kr profit på bare 29 bets!", "chartId": "leagues", "ranking": [{"name": "UEFA Champions League", "value": "+285 kr (29 bets)"}, {"name": "La Liga", "value": "-54 kr (12 bets)"}, {"name": "Danish Superliga", "value": "-68 kr (18 bets)"}, {"name": "Serie A", "value": "-241 kr (16 bets)"}, {"name": "English Premier League", "value": "-250 kr (44 bets)"}]}, {"question": "Hvor mange af 31 uger endte i plus?", "options": ["18 af 31", "22 af 31", "12 af 31", "7 af 31"], "correct": 0, "reveal": "18 af 31 — 58% af ugerne endte i plus!", "chartId": "cumulativeClub", "ranking": [{"name": "Dec", "value": "4/5 uger i plus"}, {"name": "Maj", "value": "3/8 uger i plus"}, {"name": "Aug", "value": "3/4 uger i plus"}, {"name": "Sep", "value": "3/4 uger i plus"}, {"name": "Jan", "value": "2/3 uger i plus"}, {"name": "Okt", "value": "2/3 uger i plus"}, {"name": "Nov", "value": "1/3 uger i plus"}, {"name": "Apr", "value": "0/1 uger i plus"}]}, {"question": "Hvem slap billigst i sin værste uge?", "options": ["Nixon", "Nikolaj", "Jonas", "Bjørn", "Gustav"], "correct": 0, "reveal": "Nixon klarede skærene — værste uge var kun -50 kr!", "chartId": "worstWeeks", "ranking": [{"name": "Nixon", "value": "-50 kr"}, {"name": "Nikolaj", "value": "-125 kr"}, {"name": "Bjørn", "value": "-300 kr"}, {"name": "Jonas", "value": "-300 kr"}, {"name": "Gustav", "value": "-300 kr"}]}, {"question": "Hvem spillede flest højodds-bets? (odds 3+)", "options": ["Gustav", "Nikolaj", "Nixon", "Bjørn", "Jonas"], "correct": 4, "reveal": "Jonas elsker at gamble — hele 15 bets på odds 3+!", "chartId": "highOddsPerPlayer", "ranking": [{"name": "Jonas", "value": "15 bets"}, {"name": "Nikolaj", "value": "14 bets"}, {"name": "Gustav", "value": "14 bets"}, {"name": "Bjørn", "value": "9 bets"}, {"name": "Nixon", "value": "7 bets"}]}, {"question": "Hvem endte i bunden med størst tab?", "options": ["Nikolaj", "Nixon", "Gustav", "Jonas", "Bjørn"], "correct": 2, "reveal": "Gustav tog den for holdet — -207 kr!", "chartId": "lossesPerPlayer", "ranking": [{"name": "Gustav", "value": "-207 kr"}, {"name": "Jonas", "value": "-153 kr"}, {"name": "Bjørn", "value": "-26 kr"}]}, {"question": "Hvem vandt flest af sine uger (højeste win rate)?", "options": ["Gustav", "Nixon", "Nikolaj", "Bjørn", "Jonas"], "correct": 1, "reveal": "Nixon vandt 71% af sine uger (5 af 7) — maskine!", "chartId": "winrate", "ranking": [{"name": "Nixon", "value": "71%"}, {"name": "Bjørn", "value": "67%"}, {"name": "Gustav", "value": "67%"}, {"name": "Nikolaj", "value": "50%"}, {"name": "Jonas", "value": "33%"}]}, {"question": "Hvem endte oftest ugen på en vindende bet?", "options": ["Gustav", "Jonas", "Bjørn", "Nikolaj", "Nixon"], "correct": 1, "reveal": "Jonas er Mr. Clutch — 3 af 6 uger sluttede med en vinder!", "chartId": "closerRate", "ranking": [{"name": "Jonas", "value": "3/6 uger (50%)"}, {"name": "Bjørn", "value": "2/6 uger (33%)"}, {"name": "Gustav", "value": "2/6 uger (33%)"}, {"name": "Nixon", "value": "2/7 uger (29%)"}, {"name": "Nikolaj", "value": "1/6 uger (17%)"}]}, {"question": "Hvem ramte den højeste vindende odds?", "options": ["Gustav", "Nixon", "Bjørn", "Jonas", "Nikolaj"], "correct": 4, "reveal": "Nikolaj slog til på odds 9.40 og scorede +210 kr!", "chartId": "bestWinningOdds", "ranking": [{"name": "Nikolaj", "value": "odds 9.40 (+210 kr)"}, {"name": "Nixon", "value": "odds 9.08 (+202 kr)"}, {"name": "Jonas", "value": "odds 7.00 (+300 kr)"}, {"name": "Gustav", "value": "odds 6.30 (+265 kr)"}, {"name": "Bjørn", "value": "odds 5.00 (+200 kr)"}]}, {"question": "Hvad var klubbens samlede profit i 2025?", "options": ["+1,052 kr", "+842 kr", "+715 kr", "+547 kr"], "correct": 1, "reveal": "Klubben landede på +842 kr — ikke dårligt!", "chartId": "cumulativeClub", "ranking": [{"name": "Aug", "value": "+687 kr"}, {"name": "Dec", "value": "+613 kr"}, {"name": "Sep", "value": "+152 kr"}, {"name": "Okt", "value": "+70 kr"}, {"name": "Jan", "value": "+30 kr"}, {"name": "Maj", "value": "-2 kr"}, {"name": "Apr", "value": "-182 kr"}, {"name": "Nov", "value": "-525 kr"}]}, {"question": "Hvem blev årets Tipsklub-mester med mest profit?", "options": ["Nixon", "Gustav", "Nikolaj", "Bjørn", "Jonas"], "correct": 0, "reveal": "Nixon er mesteren med +678 kr!", "chartId": "leaderboard", "ranking": [{"name": "Nixon", "value": "+678 kr"}, {"name": "Nikolaj", "value": "+549 kr"}, {"name": "Bjørn", "value": "-26 kr"}, {"name": "Jonas", "value": "-153 kr"}, {"name": "Gustav", "value": "-207 kr"}]}];
const CHART_DATA = {
    cumulative: [{"label": "Bj\u00f8rn", "data": [{"x": "2025-05-31", "y": 200.0}, {"x": "2025-08-12", "y": 247.0}, {"x": "2025-09-22", "y": 275.0}, {"x": "2025-11-03", "y": -25.0}, {"x": "2025-12-18", "y": -78.0}, {"x": "2026-01-19", "y": -26.0}], "borderColor": "#d97706", "backgroundColor": "#d97706", "borderWidth": 3, "pointRadius": 5, "pointHoverRadius": 7, "tension": 0.15, "fill": false}, {"label": "Nikolaj", "data": [{"x": "2025-05-05", "y": -125.0}, {"x": "2025-05-31", "y": -175.0}, {"x": "2025-08-25", "y": 415.0}, {"x": "2025-10-17", "y": 404.0}, {"x": "2025-11-25", "y": 479.0}, {"x": "2025-12-29", "y": 549.0}], "borderColor": "#2563eb", "backgroundColor": "#2563eb", "borderWidth": 3, "pointRadius": 5, "pointHoverRadius": 7, "tension": 0.15, "fill": false}, {"label": "Nixon", "data": [{"x": "2025-05-19", "y": 83.0}, {"x": "2025-05-31", "y": 33.0}, {"x": "2025-08-17", "y": 192.0}, {"x": "2025-09-16", "y": 567.0}, {"x": "2025-10-29", "y": 646.0}, {"x": "2025-12-09", "y": 716.0}, {"x": "2026-01-13", "y": 678.0}], "borderColor": "#16a34a", "backgroundColor": "#16a34a", "borderWidth": 3, "pointRadius": 5, "pointHoverRadius": 7, "tension": 0.15, "fill": false}, {"label": "Jonas", "data": [{"x": "2025-04-29", "y": -182.0}, {"x": "2025-05-31", "y": -232.0}, {"x": "2025-08-18", "y": -342.0}, {"x": "2025-09-30", "y": -292.0}, {"x": "2025-11-21", "y": -592.0}, {"x": "2025-12-22", "y": -153.0}], "borderColor": "#9333ea", "backgroundColor": "#9333ea", "borderWidth": 3, "pointRadius": 5, "pointHoverRadius": 7, "tension": 0.15, "fill": false}, {"label": "Gustav", "data": [{"x": "2025-05-15", "y": 40.0}, {"x": "2025-05-31", "y": -10.0}, {"x": "2025-09-13", "y": -310.0}, {"x": "2025-10-21", "y": -308.0}, {"x": "2025-12-03", "y": -222.0}, {"x": "2026-01-07", "y": -207.0}], "borderColor": "#dc2626", "backgroundColor": "#dc2626", "borderWidth": 3, "pointRadius": 5, "pointHoverRadius": 7, "tension": 0.15, "fill": false}],
    leaderboard: {"labels": ["Gustav", "Jonas", "Bj\u00f8rn", "Nikolaj", "Nixon"], "data": [-207.0, -153.0, -26.0, 549.0, 678.0], "colors": ["#dc2626", "#9333ea", "#d97706", "#2563eb", "#16a34a"]},
    winrate: {"labels": ["Nixon", "Bj\u00f8rn", "Gustav", "Nikolaj", "Jonas"], "data": [71.4, 66.7, 66.7, 50.0, 33.3], "colors": ["#16a34a", "#d97706", "#dc2626", "#2563eb", "#9333ea"], "weeks": [7, 6, 6, 6, 6], "winning": [5, 4, 4, 3, 2]},
    monthly: {"labels": ["Jan", "Apr", "Maj", "Aug", "Sep", "Okt", "Nov", "Dec"], "datasets": [{"label": "Bj\u00f8rn", "data": [52.0, 0.0, 200.0, 47.0, 28.0, 0.0, -300.0, -53.0], "backgroundColor": "#d97706"}, {"label": "Nikolaj", "data": [0.0, 0.0, -175.0, 590.0, 0.0, -11.0, 75.0, 70.0], "backgroundColor": "#2563eb"}, {"label": "Nixon", "data": [-38.0, 0.0, 33.0, 159.0, 375.0, 79.0, 0.0, 70.0], "backgroundColor": "#16a34a"}, {"label": "Jonas", "data": [0.0, -182.0, -50.0, -110.0, 50.0, 0.0, -300.0, 440.0], "backgroundColor": "#9333ea"}, {"label": "Gustav", "data": [15.0, 0.0, -10.0, 0.0, -300.0, 2.0, 0.0, 86.0], "backgroundColor": "#dc2626"}]},
    leagues: {"labels": ["Ligue 1", "UEFA Europa League", "Africa Cup of Nations", "EFL Championship", "Bundesliga", "La Liga", "Serie A", "Danish Superliga", "UEFA Champions League", "English Premier League"], "bets": [2, 2, 4, 8, 12, 12, 16, 18, 29, 44], "profit": [28.0, -62.0, 239.0, 459.0, 684.0, -54.0, -241.0, -68.0, 285.0, -250.0], "colors": ["#16a34a", "#dc2626", "#16a34a", "#16a34a", "#16a34a", "#dc2626", "#dc2626", "#dc2626", "#16a34a", "#dc2626"]},
    odds: [{"player": "Bj\u00f8rn", "odds": [5.0, 2.59, 1.77, 3.45, 2.9, 2.97, 2.45, 2.6, 3.25, 3.3, 2.88, 2.82, 7.75, 2.85, 3.2, 3.2, 3.2, 2.53, 2.47, 2.25, 2.4, 2.4, 4.0], "avg": 3.14, "min": 1.77, "max": 7.75, "color": "#d97706"}, {"player": "Nikolaj", "odds": [3.9, 4.2, 3.5, 3.5, 2.1, 5.5, 3.2, 4.28, 4.95, 4.18, 9.4, 1.7, 2.89, 3.1, 2.1, 2.55, 3.75, 2.6, 3.2, 3.2, 2.28, 1.42], "avg": 3.52, "min": 1.42, "max": 9.4, "color": "#2563eb"}, {"player": "Nixon", "odds": [2.03, 2.05, 2.4, 2.21, 2.0, 2.59, 3.48, 9.08, 15.0, 2.35, 2.7, 3.3, 2.73, 4.45, 2.72, 3.6, 3.7, 2.1, 2.7, 2.1, 2.7], "avg": 3.62, "min": 2.0, "max": 15.0, "color": "#16a34a"}, {"player": "Jonas", "odds": [3.36, 2.5, 2.35, 3.2, 3.5, 0.55, 2.4, 3.61, 3.25, 3.11, 4.98, 3.03, 7.0, 2.5, 3.04, 4.48, 2.88, 2.4, 3.65, 3.08, 3.68, 3.75], "avg": 3.29, "min": 0.55, "max": 7.0, "color": "#9333ea"}, {"player": "Gustav", "odds": [3.06, 1.9, 9.0, 1.85, 2.5, 2.3, 15.0, 19.0, 3.3, 2.9, 3.02, 6.0, 4.0, 2.2, 2.7, 3.86, 2.02, 9.0, 3.44, 3.25, 3.66, 6.3], "avg": 5.01, "min": 1.85, "max": 19.0, "color": "#dc2626"}],
    bigweeks: {"labels": ["Gustav (13/09)", "Bj\u00f8rn (03/11)", "Jonas (21/11)", "Jonas (29/04)", "Nikolaj (05/05)", "Nikolaj (25/08)", "Jonas (22/12)", "Nixon (16/09)", "Bj\u00f8rn (31/05)", "Nixon (17/08)"], "data": [-300.0, -300.0, -300.0, -182.0, -125.0, 590.0, 440.0, 375.0, 200.0, 159.0], "colors": ["#dc2626", "#d97706", "#9333ea", "#9333ea", "#2563eb", "#2563eb", "#9333ea", "#16a34a", "#d97706", "#16a34a"]},
    bestWeeks: {"labels": ["Nixon (17/08)", "Bj\u00f8rn (31/05)", "Nixon (16/09)", "Jonas (22/12)", "Nikolaj (25/08)"], "data": [159.0, 200.0, 375.0, 440.0, 590.0], "colors": ["#16a34a", "#d97706", "#16a34a", "#9333ea", "#2563eb"]},
    worstWeeks: {"labels": ["Gustav (13/09)", "Bj\u00f8rn (03/11)", "Jonas (21/11)", "Jonas (29/04)", "Nikolaj (05/05)"], "data": [-300.0, -300.0, -300.0, -182.0, -125.0], "colors": ["#dc2626", "#d97706", "#9333ea", "#9333ea", "#2563eb"]},
    cumulativeClub: [{"label": "Klubben", "data": [{"x": "2025-04-29", "y": -182.0}, {"x": "2025-05-05", "y": -308.0}, {"x": "2025-05-15", "y": -268.0}, {"x": "2025-05-19", "y": -185.0}, {"x": "2025-05-31", "y": -185.0}, {"x": "2025-08-12", "y": -137.0}, {"x": "2025-08-17", "y": 22.0}, {"x": "2025-08-18", "y": -88.0}, {"x": "2025-08-25", "y": 502.0}, {"x": "2025-09-13", "y": 202.0}, {"x": "2025-09-16", "y": 577.0}, {"x": "2025-09-22", "y": 604.0}, {"x": "2025-09-30", "y": 654.0}, {"x": "2025-10-17", "y": 643.0}, {"x": "2025-10-21", "y": 645.0}, {"x": "2025-10-29", "y": 724.0}, {"x": "2025-11-03", "y": 424.0}, {"x": "2025-11-21", "y": 124.0}, {"x": "2025-11-25", "y": 199.0}, {"x": "2025-12-03", "y": 285.0}, {"x": "2025-12-09", "y": 355.0}, {"x": "2025-12-18", "y": 302.0}, {"x": "2025-12-22", "y": 742.0}, {"x": "2025-12-29", "y": 812.0}, {"x": "2026-01-07", "y": 827.0}, {"x": "2026-01-13", "y": 789.0}, {"x": "2026-01-19", "y": 842.0}], "borderColor": "#2563eb", "backgroundColor": "#2563eb", "borderWidth": 3, "pointRadius": 4, "pointHoverRadius": 6, "tension": 0.15, "fill": false}],
    weekdayTotal: {"labels": ["Man", "Tir", "Ons", "Tor", "Fre", "L\u00f8r", "S\u00f8n"], "data": [9, 15, 16, 7, 10, 36, 17], "profit": [38.0, -234.0, 360.0, -17.0, 182.0, 604.0, -91.0]},
    betsPerPlayer: {"labels": ["Nixon", "Nikolaj", "Jonas", "Gustav", "Bj\u00f8rn"], "data": [21, 22, 22, 22, 23], "colors": ["#16a34a", "#2563eb", "#9333ea", "#dc2626", "#d97706"]},
    highOddsPerPlayer: {"labels": ["Nixon", "Bj\u00f8rn", "Nikolaj", "Gustav", "Jonas"], "data": [7, 9, 14, 14, 15], "colors": ["#16a34a", "#d97706", "#2563eb", "#dc2626", "#9333ea"]},
    lossesPerPlayer: {"labels": ["Gustav", "Jonas", "Bj\u00f8rn"], "data": [-207.0, -153.0, -26.0], "colors": ["#dc2626", "#9333ea", "#d97706"]},
    closerRate: {"labels": ["Jonas", "Bj\u00f8rn", "Gustav", "Nixon", "Nikolaj"], "data": [50.0, 33.3, 33.3, 28.6, 16.7], "colors": ["#9333ea", "#d97706", "#dc2626", "#16a34a", "#2563eb"]},
    bestWinningOdds: {"labels": ["Bj\u00f8rn", "Gustav", "Jonas", "Nixon", "Nikolaj"], "data": [5.0, 6.3, 7.0, 9.08, 9.4], "colors": ["#d97706", "#dc2626", "#9333ea", "#16a34a", "#2563eb"]},
};
const QUICK_STATS = {"weeks": 31, "bets": 110, "staked": 7750.0, "profit": 842.0};
const PLAYER_COLORS = {"Bj\u00f8rn": "#d97706", "Nikolaj": "#2563eb", "Nixon": "#16a34a", "Jonas": "#9333ea", "Gustav": "#dc2626"};

// ── QR Code ──
function drawQR(canvas, text) {
    const qr = qrcode(0, 'M');
    qr.addData(text);
    qr.make();
    const modules = qr.getModuleCount();
    const cellSize = Math.floor(180 / modules);
    const size = cellSize * modules;
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, size, size);
    for (let r = 0; r < modules; r++) {
        for (let c = 0; c < modules; c++) {
            ctx.fillStyle = qr.isDark(r, c) ? '#1e293b' : '#fff';
            ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
        }
    }
}

// ── State ──
let mode = ''; // 'host' or 'player'
let peer = null;
let connections = []; // host: array of DataConnection
let hostConn = null; // player: DataConnection to host
let roomCode = '';
let players = {}; // host: {connId: {name, score, answered, correct_count}}
let currentQ = 0;
let votes = {}; // host: {optionIndex: [playerNames]}
let myAnswer = -1;
let myScore = 0;
let myCorrectCount = 0;
let answerOrder = []; // host: tracks order of correct answers for speed bonus
let revealChart = null;
let quizStarted = false;
let disconnectedPlayers = {}; // host: name -> player data (preserved on disconnect)
const TIMER_DURATION = 30; // seconds per question
let timerRAF = null;
let questionStartTime = 0;
let answersLocked = false;
let lastEarned = {}; // host: connId -> points earned this round
let audioCtx = null;

// ── Audio (Web Audio API) ──
function getAudioCtx() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
}
function playSound(type) {
    try {
        const ctx = getAudioCtx();
        if (ctx.state === 'suspended') ctx.resume();
        if (type === 'correct') {
            [523.25, 659.25, 783.99].forEach((freq, i) => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination); o.type = 'sine';
                o.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.12);
                g.gain.setValueAtTime(0.25, ctx.currentTime + i * 0.12);
                g.gain.linearRampToValueAtTime(0, ctx.currentTime + i * 0.12 + 0.3);
                o.start(ctx.currentTime + i * 0.12); o.stop(ctx.currentTime + i * 0.12 + 0.3);
            });
        } else if (type === 'wrong') {
            const o = ctx.createOscillator(); const g = ctx.createGain();
            o.connect(g); g.connect(ctx.destination); o.type = 'sawtooth';
            o.frequency.setValueAtTime(200, ctx.currentTime);
            o.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.3);
            g.gain.setValueAtTime(0.15, ctx.currentTime);
            g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.3);
        } else if (type === 'tick') {
            const o = ctx.createOscillator(); const g = ctx.createGain();
            o.connect(g); g.connect(ctx.destination); o.type = 'sine';
            o.frequency.setValueAtTime(880, ctx.currentTime);
            g.gain.setValueAtTime(0.08, ctx.currentTime);
            g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.06);
            o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.06);
        } else if (type === 'fanfare') {
            [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination); o.type = 'triangle';
                o.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.18);
                g.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.18);
                g.gain.linearRampToValueAtTime(0, ctx.currentTime + i * 0.18 + 0.5);
                o.start(ctx.currentTime + i * 0.18); o.stop(ctx.currentTime + i * 0.18 + 0.5);
            });
        }
    } catch(e) {}
}

// ── Timer ──
function startTimer(barId, textId, onExpire) {
    questionStartTime = Date.now();
    answersLocked = false;
    const bar = document.getElementById(barId);
    const text = document.getElementById(textId);
    const duration = TIMER_DURATION * 1000;
    let lastSecs = -1;
    if (bar) { bar.style.width = '100%'; }
    if (text) { text.textContent = TIMER_DURATION; text.classList.remove('urgent'); }

    cancelAnimationFrame(timerRAF);
    function tick() {
        const elapsed = Date.now() - questionStartTime;
        const remaining = Math.max(0, duration - elapsed);
        const pct = remaining / duration * 100;
        if (bar) bar.style.width = pct + '%';
        const secs = Math.ceil(remaining / 1000);
        if (text && secs !== lastSecs) {
            text.textContent = secs;
            if (secs <= 5 && secs > 0) {
                text.classList.add('urgent');
                if (mode === 'player') playSound('tick');
            }
            lastSecs = secs;
        }
        if (remaining > 0) {
            timerRAF = requestAnimationFrame(tick);
        } else {
            if (text) { text.textContent = '0'; text.classList.add('urgent'); }
            if (onExpire) onExpire();
        }
    }
    timerRAF = requestAnimationFrame(tick);
}
function stopTimer() {
    cancelAnimationFrame(timerRAF);
    timerRAF = null;
}

// ── Confetti ──
function showConfetti() {
    const canvas = document.getElementById('confettiCanvas');
    canvas.style.display = 'block';
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext('2d');
    const colors = ['#fbbf24','#dc2626','#2563eb','#16a34a','#d97706','#7c3aed','#f472b6'];
    const particles = [];
    for (let i = 0; i < 180; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height - canvas.height,
            w: Math.random() * 10 + 4, h: Math.random() * 6 + 3,
            color: colors[Math.floor(Math.random() * colors.length)],
            vx: Math.random() * 6 - 3, vy: Math.random() * 3 + 2,
            spin: Math.random() * 0.2 - 0.1, angle: Math.random() * Math.PI * 2
        });
    }
    let frame = 0;
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.angle += p.spin; p.vy += 0.06;
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, 1 - frame / 200);
            ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h); ctx.restore();
        });
        frame++;
        if (frame < 200) requestAnimationFrame(animate);
        else canvas.style.display = 'none';
    }
    animate();
}

// ── Score popup ──
function showScorePopup(text) {
    const el = document.createElement('div');
    el.className = 'score-popup';
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 2000);
}

// ── Screen management ──
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}
function updateProgress() {
    const pct = quizStarted ? ((currentQ + 1) / QUESTIONS.length * 100) : 0;
    document.getElementById('progressBar').style.width = pct + '%';
}

// ── ICE config (STUN + Cloudflare TURN) ──
const ICE_CONFIG = {iceServers: [{"urls": ["stun:stun.cloudflare.com:3478", "turn:turn.cloudflare.com:3478?transport=udp", "turn:turn.cloudflare.com:3478?transport=tcp", "turns:turn.cloudflare.com:5349?transport=tcp"], "username": "g030935eaa771ecdb62875be009865c2bc22499591131d28f8fa0deb8b4cd9a0", "credential": "c7bec2a78cb60fa10d692cc087bf9b358c2b221fec44039d3374a425332d2207"}]};

// ── HOST ──
function startHost() {
    mode = 'host';
    roomCode = genCode();
    document.getElementById('roomCodeDisplay').textContent = roomCode;
    const peerId = 'tipsklub-' + roomCode.toLowerCase();

    peer = new Peer(peerId, { debug: 2, config: ICE_CONFIG });
    peer.on('open', (id) => {
        console.log('Host peer open:', id);
        const url = location.href.split('?')[0] + '?room=' + roomCode;
        drawQR(document.getElementById('qrCanvas'), url);
        showScreen('screenHostLobby');
    });
    peer.on('error', (err) => {
        console.error('Host peer error:', err.type, err);
        if (err.type === 'unavailable-id') {
            roomCode = genCode();
            document.getElementById('roomCodeDisplay').textContent = roomCode;
            peer.destroy();
            startHost();
        }
    });
    peer.on('connection', (conn) => {
        conn.on('open', () => {
            connections.push(conn);
            conn.on('data', (data) => handleHostMessage(conn, data));
            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
                const p = players[conn.connectionId];
                if (p) {
                    // Preserve player data for reconnection
                    disconnectedPlayers[p.name] = p;
                    delete players[conn.connectionId];
                }
                updatePlayerList();
            });
        });
    });
}

function genCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
    let code = '';
    for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
}

function handleHostMessage(conn, data) {
    if (data.type === 'join') {
        // Check if reconnecting player
        if (disconnectedPlayers[data.name]) {
            players[conn.connectionId] = disconnectedPlayers[data.name];
            delete disconnectedPlayers[data.name];
            console.log('Player reconnected:', data.name);
        } else {
            players[conn.connectionId] = { name: data.name, score: 0, answered: false, correct_count: 0, answers: [] };
        }
        updatePlayerList();
        conn.send({ type: 'joined', name: data.name });

        // If quiz is in progress, send current question
        if (quizStarted && currentQ < QUESTIONS.length) {
            const q = QUESTIONS[currentQ];
            conn.send({ type: 'question', index: currentQ, question: q.question, options: q.options });
        }
    }
    if (data.type === 'answer') {
        if (answersLocked) return; // Timer expired
        const p = players[conn.connectionId];
        if (!p) return;
        const optIdx = parseInt(data.option);

        // Remove previous vote if changing answer
        if (p.answered) {
            for (const key of Object.keys(votes)) {
                const arr = votes[key];
                const idx = arr.indexOf(p.name);
                if (idx !== -1) arr.splice(idx, 1);
            }
            answerOrder = answerOrder.filter(id => id !== conn.connectionId);
        }

        p.answered = true;
        p.answerTime = Date.now() - questionStartTime; // track response time
        if (!votes[optIdx]) votes[optIdx] = [];
        votes[optIdx].push(p.name);

        // Track correct answer order for speed bonus (first correct stays first)
        const q = QUESTIONS[currentQ];
        if (optIdx === q.correct) {
            answerOrder.push(conn.connectionId);
        }

        updateHostVotes();
    }
}

function updatePlayerList() {
    const list = document.getElementById('playerList');
    const connected = Object.values(players).map(p => p.name);
    const disconnected = Object.keys(disconnectedPlayers);
    let html = connected.map(n => {
        const color = PLAYER_COLORS[n] || '#2563eb';
        return `<div class="player-chip"><div class="player-dot" style="background:${color}"></div>${n}</div>`;
    }).join('');
    html += disconnected.map(n => {
        return `<div class="player-chip" style="opacity:.4"><div class="player-dot" style="background:#64748b"></div>${n} (frakoblet)</div>`;
    }).join('');
    list.innerHTML = html;
}

function updateHostVotes() {
    const q = QUESTIONS[currentQ];
    const totalPlayers = Object.keys(players).length;
    const totalVotes = Object.values(votes).reduce((s, arr) => s + arr.length, 0);

    q.options.forEach((opt, i) => {
        const count = (votes[i] || []).length;
        const el = document.getElementById('hostOpt' + i);
        if (el) {
            el.querySelector('.count').textContent = count;
        }
    });
    document.getElementById('hostVoteCount').textContent = totalVotes + ' / ' + totalPlayers + ' har svaret';
}

function hostStartQuiz() {
    currentQ = 0;
    quizStarted = true;
    hostSendQuestion();
}

function hostSendQuestion() {
    const q = QUESTIONS[currentQ];
    votes = {};
    answerOrder = [];
    lastEarned = {};
    answersLocked = false;
    Object.values(players).forEach(p => { p.answered = false; p.answerTime = null; });

    // Update host screen
    document.getElementById('statusRoom').textContent = roomCode;
    document.getElementById('statusQ').textContent = (currentQ + 1) + ' / ' + QUESTIONS.length;
    document.getElementById('hostQNum').textContent = 'Spørgsmål ' + (currentQ + 1) + ' af ' + QUESTIONS.length;
    document.getElementById('hostQText').textContent = q.question;

    let optsHtml = '';
    q.options.forEach((opt, i) => {
        optsHtml += `<div class="host-opt" id="hostOpt${i}"><span>${opt}</span><span class="count">0</span></div>`;
    });
    document.getElementById('hostOptions').innerHTML = optsHtml;
    document.getElementById('hostVoteCount').textContent = '0 / ' + Object.keys(players).length + ' har svaret';
    const btn = document.getElementById('btnReveal');
    btn.className = 'btn btn-reveal';
    btn.textContent = 'Vis Svar';
    btn.onclick = hostReveal;

    updateProgress();
    showScreen('screenHostQ');

    // Start countdown timer on host
    startTimer('hostTimerBar', 'hostTimerText', () => {
        answersLocked = true;
        document.getElementById('hostTimerText').textContent = 'Tid!';
    });

    // Send to players
    const msg = { type: 'question', index: currentQ, question: q.question, options: q.options, timer: TIMER_DURATION };
    connections.forEach(c => c.send(msg));
}

function hostReveal() {
    stopTimer();
    answersLocked = true;
    const q = QUESTIONS[currentQ];
    document.getElementById('btnReveal').classList.add('btn-disabled');

    // Highlight correct/wrong and show who picked what
    q.options.forEach((opt, i) => {
        const el = document.getElementById('hostOpt' + i);
        el.classList.add(i === q.correct ? 'correct' : 'wrong');
        const names = votes[i] || [];
        if (names.length > 0) {
            el.innerHTML += `<div class="vote-names">${names.join(', ')}</div>`;
        }
    });

    // Calculate time-based scores and record answers
    lastEarned = {};
    Object.entries(players).forEach(([connId, p]) => {
        let playerVote = -1;
        Object.entries(votes).forEach(([optIdx, names]) => {
            if (names.includes(p.name)) playerVote = parseInt(optIdx);
        });
        const wasCorrect = playerVote === q.correct;
        let earned = 0;
        if (wasCorrect) {
            // Time-based scoring: 500-1000 pts based on response time
            const elapsed = p.answerTime || (TIMER_DURATION * 1000);
            const timeFraction = Math.min(elapsed / (TIMER_DURATION * 1000), 1);
            earned = Math.round(500 + 500 * (1 - timeFraction));
            // Speed bonus: +200 for first correct answer
            if (answerOrder.length > 0 && answerOrder[0] === connId) {
                earned += 200;
            }
            p.score += earned;
            p.correct_count += 1;
        }
        lastEarned[connId] = earned;
        p.answers.push({
            question: q.question,
            picked: playerVote >= 0 ? q.options[playerVote] : '—',
            correct: q.options[q.correct],
            right: wasCorrect,
        });
    });

    // Send reveal to each player with their individual earned points
    const scores = {};
    Object.values(players).forEach(p => { scores[p.name] = p.score; });
    connections.forEach(c => {
        const p = players[c.connectionId];
        const earned = lastEarned[c.connectionId] || 0;
        c.send({ type: 'reveal', correct: q.correct, correctText: q.options[q.correct], earned, scores });
    });

    // Change button to advance to chart/ranking reveal
    const btn = document.getElementById('btnReveal');
    btn.classList.remove('btn-disabled');
    btn.classList.remove('btn-reveal');
    btn.classList.add('btn-next');
    btn.textContent = 'Vis Detaljer';
    btn.onclick = () => showRevealScreen(q);
}

function showRevealScreen(q) {
    document.getElementById('statusRoom2').textContent = roomCode;
    document.getElementById('statusQ2').textContent = (currentQ + 1) + ' / ' + QUESTIONS.length;
    document.getElementById('revealText').textContent = q.reveal;

    // Render ranking list
    const rankEl = document.getElementById('rankingList');
    if (q.ranking && q.ranking.length > 0) {
        rankEl.innerHTML = q.ranking.map((r, i) => {
            const cls = i === 0 ? 'rank-row gold' : 'rank-row';
            const color = PLAYER_COLORS[r.name] || '';
            const nameStyle = color ? ` style="color:${color}"` : '';
            return `<div class="${cls}"><span class="rank-pos">${i+1}.</span><span class="rank-name"${nameStyle}>${r.name}</span><span class="rank-val">${r.value}</span></div>`;
        }).join('');
    } else {
        rankEl.innerHTML = '';
    }

    const chartContainer = document.getElementById('chartRevealContainer');
    const qsContainer = document.getElementById('quickStatsReveal');

    // Destroy previous chart
    if (revealChart) { revealChart.destroy(); revealChart = null; }

    if (q.chartId === 'quickstats') {
        chartContainer.style.display = 'none';
        qsContainer.style.display = 'grid';
        const qs = QUICK_STATS;
        const profitColor = qs.profit >= 0 ? '#16a34a' : '#dc2626';
        qsContainer.innerHTML = `
            <div class="qs-item"><div class="val">${qs.weeks}</div><div class="lbl">Uger spillet</div></div>
            <div class="qs-item"><div class="val">${qs.bets}</div><div class="lbl">Bets i alt</div></div>
            <div class="qs-item"><div class="val">${qs.staked.toLocaleString('da-DK')}</div><div class="lbl">Satset (kr)</div></div>
            <div class="qs-item"><div class="val" style="color:${profitColor}">${qs.profit >= 0 ? '+' : ''}${qs.profit.toLocaleString('da-DK')}</div><div class="lbl">Klub Profit</div></div>
        `;
    } else {
        chartContainer.style.display = 'block';
        qsContainer.style.display = 'none';

        // Replace canvas (Chart.js reuse quirk)
        const oldCanvas = document.getElementById('chartReveal');
        const newCanvas = document.createElement('canvas');
        newCanvas.id = 'chartReveal';
        newCanvas.height = 200;
        oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);

        revealChart = renderChart(newCanvas, q.chartId);
    }

    // Mini-scoreboard (live standings)
    const miniSb = document.getElementById('miniScoreboard');
    const sorted = Object.values(players).sort((a, b) => b.score - a.score);
    miniSb.innerHTML = '<div class="mini-sb-title">Standings</div>' +
        sorted.map((p, i) => {
            const color = PLAYER_COLORS[p.name] || '#2563eb';
            const connId = Object.entries(players).find(([k, v]) => v === p)?.[0];
            const earned = connId ? (lastEarned[connId] || 0) : 0;
            const earnedHtml = earned > 0 ? `<span class="mini-sb-earned">+${earned}</span>` : '';
            const posClass = i === 0 ? 'mini-sb-pos first' : 'mini-sb-pos';
            return `<div class="mini-sb-row" style="animation-delay:${i * 0.08}s">
                <span class="${posClass}">${i + 1}.</span>
                <span class="mini-sb-name" style="color:${color}">${p.name}</span>
                <span class="mini-sb-score">${p.score}</span>${earnedHtml}
            </div>`;
        }).join('');

    // Button text
    const btnNext = document.getElementById('btnNext');
    if (currentQ >= QUESTIONS.length - 1) {
        btnNext.textContent = 'Vis Scoreboard';
    } else {
        btnNext.textContent = 'Næste Spørgsmål';
    }

    showScreen('screenHostReveal');
}

function renderChart(canvas, chartId) {
    const ctx = canvas;
    Chart.defaults.font.family = "'Inter', system-ui, sans-serif";
    Chart.defaults.color = '#475569';

    if (chartId === 'leaderboard') {
        const d = CHART_DATA.leaderboard;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x.toLocaleString('da-DK')+' kr' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'winrate') {
        const d = CHART_DATA.winrate;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: (c) => {
                    const idx=c.dataIndex; return c.parsed.y+'% ('+d.winning[idx]+'/'+d.weeks[idx]+' uger)';
                } } } },
                scales:{ y:{ max:100, grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+'%' } }, x:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'odds') {
        const d = CHART_DATA.odds;
        const labels = d.map(p=>p.player);
        const avgs = d.map(p=>p.avg);
        const colors = d.map(p=>p.color);
        return new Chart(ctx, {
            type: 'bar',
            data: { labels, datasets: [{ label:'Gns.', data:avgs, backgroundColor:colors, borderRadius:4 }] },
            options: { responsive:true,
                scales:{ y:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Odds' } }, x:{ grid:{ display:false } } },
                plugins:{ legend:{ display:false } }
            }
        });
    }
    if (chartId === 'monthly') {
        const d = CHART_DATA.monthly;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: d.datasets.map(ds => ({ ...ds, borderRadius: 2 })) },
            options: { responsive:true,
                plugins:{ tooltip:{ callbacks:{ label: c => c.dataset.label+': '+c.parsed.y.toLocaleString('da-DK')+' kr' } } },
                scales:{ y:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, x:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'leagues') {
        const d = CHART_DATA.leagues;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.bets, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => {
                    const idx=c.dataIndex; return c.parsed.x+' bets | '+d.profit[idx].toLocaleString('da-DK')+' kr profit';
                } } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Antal bets' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'bigweeks') {
        const d = CHART_DATA.bigweeks;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x.toLocaleString('da-DK')+' kr' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'bestWeeks') {
        const d = CHART_DATA.bestWeeks;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x.toLocaleString('da-DK')+' kr' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'worstWeeks') {
        const d = CHART_DATA.worstWeeks;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x.toLocaleString('da-DK')+' kr' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'cumulativeClub') {
        const datasets = CHART_DATA.cumulativeClub;
        return new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: { responsive:true,
                scales: {
                    x: { type:'time', time:{ unit:'month', displayFormats:{ month:'MMM' } }, grid:{ color:'#f1f5f9' } },
                    y: { grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }
                },
                plugins:{ tooltip:{ callbacks:{ label: c => c.parsed.y.toLocaleString('da-DK')+' kr' } } }
            }
        });
    }
    if (chartId === 'weekdayTotal') {
        const d = CHART_DATA.weekdayTotal;
        const colors = d.data.map((v, i) => {
            const maxVal = Math.max(...d.data);
            return v === maxVal ? '#2563eb' : '#94a3b8';
        });
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: colors, borderRadius: 4 }] },
            options: { responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => {
                    const idx=c.dataIndex; return c.parsed.y+' bets | '+d.profit[idx].toLocaleString('da-DK')+' kr profit';
                } } } },
                scales:{ y:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Antal bets' } }, x:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'betsPerPlayer') {
        const d = CHART_DATA.betsPerPlayer;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x+' bets' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Antal bets' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'highOddsPerPlayer') {
        const d = CHART_DATA.highOddsPerPlayer;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x+' bets (odds 3+)' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Antal højodds-bets' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'lossesPerPlayer') {
        const d = CHART_DATA.lossesPerPlayer;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.x.toLocaleString('da-DK')+' kr' } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'closerRate') {
        const d = CHART_DATA.closerRate;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => c.parsed.y+'%' } } },
                scales:{ y:{ max:100, grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+'%' } }, x:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'bestWinningOdds') {
        const d = CHART_DATA.bestWinningOdds;
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: d.labels, datasets: [{ data: d.data, backgroundColor: d.colors, borderRadius: 4 }] },
            options: { indexAxis:'y', responsive:true,
                plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: c => 'odds '+c.parsed.x.toFixed(2) } } },
                scales:{ x:{ grid:{ color:'#f1f5f9' }, title:{ display:true, text:'Højeste vindende odds' } }, y:{ grid:{ display:false } } }
            }
        });
    }
    if (chartId === 'cumulative') {
        const datasets = CHART_DATA.cumulative;
        return new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: { responsive:true, interaction:{ mode:'index', intersect:false },
                scales: {
                    x: { type:'time', time:{ unit:'month', displayFormats:{ month:'MMM' } }, grid:{ color:'#f1f5f9' } },
                    y: { grid:{ color:'#f1f5f9' }, ticks:{ callback: v=>v+' kr' } }
                },
                plugins:{ tooltip:{ callbacks:{ label: c => c.dataset.label+': '+c.parsed.y.toLocaleString('da-DK')+' kr' } } }
            }
        });
    }
    return null;
}

const HALFTIME_AFTER = Math.floor(QUESTIONS.length / 2); // show halftime after this question
let halftimeShown = false;

function hostNextQuestion() {
    currentQ++;
    if (currentQ >= QUESTIONS.length) {
        showFinalScoreboard();
    } else if (currentQ === HALFTIME_AFTER && !halftimeShown) {
        halftimeShown = true;
        showHalftime();
    } else {
        hostSendQuestion();
    }
}

function showHalftime() {
    const sorted = Object.values(players).sort((a, b) => b.score - a.score);
    const rankIcons = ['gold', 'silver', 'bronze'];
    let html = '';
    sorted.forEach((p, i) => {
        const rankClass = i < 3 ? rankIcons[i] : '';
        const rank = i < 3 ? ['1','2','3'][i] : (i + 1);
        const color = PLAYER_COLORS[p.name] || '#2563eb';
        html += `<div class="sb-row" style="animation-delay:${i * 0.1}s">
            <div class="sb-rank ${rankClass}">${rank}</div>
            <div class="sb-name" style="color:${color}">${p.name}</div>
            <div><span class="sb-score">${p.score} pts</span><span class="sb-correct">${p.correct_count}/${HALFTIME_AFTER}</span></div>
        </div>`;
    });
    document.getElementById('halftimeScoreboard').innerHTML = html;
    showScreen('screenHalftime');

    // Send halftime to players
    const scoresArr = sorted.map(p => ({ name: p.name, score: p.score, correct: p.correct_count }));
    connections.forEach(c => c.send({ type: 'halftime', scores: scoresArr }));
}

function halftimeContinue() {
    hostSendQuestion();
}

function showFinalScoreboard() {
    const sorted = Object.values(players).sort((a, b) => b.score - a.score);
    const rankIcons = ['gold', 'silver', 'bronze'];
    const rankEmoji = ['1', '2', '3'];

    // Winner banner
    if (sorted.length > 0) {
        const winner = sorted[0];
        const winnerColor = PLAYER_COLORS[winner.name] || '#fbbf24';
        document.getElementById('winnerBanner').innerHTML =
            `<span style="color:${winnerColor}">${winner.name}</span> vinder!`;
    }

    let html = '';
    sorted.forEach((p, i) => {
        const rankClass = i < 3 ? rankIcons[i] : '';
        const rank = i < 3 ? rankEmoji[i] : (i + 1);
        const color = PLAYER_COLORS[p.name] || '#2563eb';
        const pid = 'answers-' + i;
        const delay = (sorted.length - 1 - i) * 0.15; // reveal bottom-up: winner appears last
        html += `<div class="sb-row" onclick="document.getElementById('${pid}').style.display=document.getElementById('${pid}').style.display==='none'?'block':'none'" style="cursor:pointer;animation-delay:${delay}s;opacity:0;">
            <div class="sb-rank ${rankClass}">${rank}</div>
            <div class="sb-name" style="color:${color}">${p.name}</div>
            <div><span class="sb-score">${p.score} pts</span><span class="sb-correct">${p.correct_count}/${QUESTIONS.length}</span></div>
        </div>
        <div id="${pid}" class="sb-answers" style="display:none;">`;
        if (p.answers) {
            p.answers.forEach((a, qi) => {
                const icon = a.right ? '<span style="color:#16a34a">&#10003;</span>' : '<span style="color:#dc2626">&#10007;</span>';
                html += `<div class="sb-answer">${icon} <span class="sb-aq">Q${qi+1}</span> ${a.picked}</div>`;
            });
        }
        html += `</div>`;
    });
    document.getElementById('scoreboard').innerHTML = html;

    // Send to players (include answers for their own view)
    const scoresArr = sorted.map(p => ({ name: p.name, score: p.score, correct: p.correct_count, answers: p.answers }));
    connections.forEach(c => c.send({ type: 'scoreboard', scores: scoresArr }));

    showScreen('screenScoreboard');

    // Celebration effects (delayed to coincide with winner row appearing)
    const celebDelay = (sorted.length - 1) * 150 + 300;
    setTimeout(() => {
        playSound('fanfare');
        showConfetti();
    }, celebDelay);
}

// ── PLAYER ──
function showJoin() {
    // Check URL params for pre-filled room code
    const params = new URLSearchParams(location.search);
    const urlRoom = params.get('room');
    if (urlRoom) {
        document.getElementById('inputCode').value = urlRoom.toUpperCase();
    }
    showScreen('screenJoin');
}

function joinRoom() {
    const code = document.getElementById('inputCode').value.trim().toUpperCase();
    const name = document.getElementById('inputName').value.trim();
    const errEl = document.getElementById('joinError');

    if (!code || code.length !== 4) { errEl.textContent = 'Indtast en 4-bogstavs kode'; return; }
    if (!name) { errEl.textContent = 'Indtast dit navn'; return; }
    errEl.textContent = '';

    mode = 'player';
    roomCode = code;
    const peerId = 'tipsklub-' + code.toLowerCase();

    errEl.textContent = '';
    errEl.style.color = '#94a3b8';
    errEl.textContent = 'Forbinder...';

    peer = new Peer({ debug: 2, config: ICE_CONFIG });
    peer.on('open', (myId) => {
        console.log('Player peer open:', myId, '-> connecting to:', peerId);
        errEl.textContent = 'Forbundet til server, finder vært...';
        hostConn = peer.connect(peerId, { reliable: true, serialization: 'json' });
        hostConn.on('open', () => {
            console.log('Connection to host open!');
            errEl.textContent = '';
            errEl.style.color = '';
            hostConn.send({ type: 'join', name });
            hostConn.on('data', (data) => handlePlayerMessage(data, name));
        });
        hostConn.on('error', (err) => {
            errEl.style.color = '';
            errEl.textContent = 'Forbindelse fejlede: ' + (err.type || err);
            console.error('Connection error:', err);
        });
        hostConn.on('close', () => {
            console.log('Connection to host closed, attempting reconnect...');
            attemptReconnect(peerId, name);
        });
    });
    peer.on('error', (err) => {
        errEl.style.color = '';
        console.error('Peer error:', err.type, err);
        if (err.type === 'peer-unavailable') {
            errEl.textContent = 'Vært ikke fundet. Tjek koden og at vært er online.';
        } else {
            errEl.textContent = 'Forbindelsesfejl: ' + err.type;
        }
    });
    peer.on('disconnected', () => {
        console.log('Peer disconnected from signaling server');
    });

    // Timeout for connection
    setTimeout(() => {
        if (!hostConn || !hostConn.open) {
            if (errEl.textContent.includes('Forbinder') || errEl.textContent.includes('finder')) {
                errEl.style.color = '';
                errEl.textContent = 'Timeout. Tjek koden og prøv igen.';
            }
        }
    }, 10000);
}

function attemptReconnect(peerId, name) {
    let attempts = 0;
    const maxAttempts = 5;
    function tryConnect() {
        if (attempts >= maxAttempts) return;
        attempts++;
        console.log('Reconnect attempt', attempts);
        // Ensure peer is still connected to signaling server
        if (peer.disconnected) {
            peer.reconnect();
        }
        setTimeout(() => {
            if (!peer.open) { tryConnect(); return; }
            hostConn = peer.connect(peerId, { reliable: true, serialization: 'json' });
            hostConn.on('open', () => {
                console.log('Reconnected!');
                hostConn.send({ type: 'join', name });
                hostConn.on('data', (data) => handlePlayerMessage(data, name));
                hostConn.on('close', () => {
                    console.log('Connection lost again, reconnecting...');
                    attemptReconnect(peerId, name);
                });
            });
            hostConn.on('error', () => {
                setTimeout(tryConnect, 2000);
            });
        }, 2000);
    }
    tryConnect();
}

function handlePlayerMessage(data, myName) {
    if (data.type === 'joined') {
        showScreen('screenPlayerWait');
    }
    if (data.type === 'question') {
        myAnswer = -1;
        answersLocked = false;
        document.getElementById('playerQNum').textContent = 'Spørgsmål ' + (data.index + 1) + ' af ' + QUESTIONS.length;
        document.getElementById('playerQText').textContent = data.question;
        let html = '';
        data.options.forEach((opt, i) => {
            html += `<button class="answer-btn" id="ansBtn${i}" onclick="playerAnswer(${i})">${opt}</button>`;
        });
        document.getElementById('playerOptions').innerHTML = html;
        updateProgress();
        showScreen('screenPlayerQ');

        // Start player timer
        const duration = data.timer || TIMER_DURATION;
        startTimer('playerTimerBar', 'playerTimerText', () => {
            answersLocked = true;
            document.getElementById('playerTimerText').textContent = 'Tid!';
            document.querySelectorAll('.answer-btn').forEach(b => b.classList.add('locked'));
        });
    }
    if (data.type === 'reveal') {
        stopTimer();
        const q = data;
        const wasCorrect = myAnswer === q.correct;
        const fb = document.getElementById('playerFeedback');
        const detail = document.getElementById('playerFeedbackDetail');
        const earnedEl = document.getElementById('playerEarned');

        if (myAnswer === -1) {
            fb.textContent = 'Ikke svaret!';
            fb.className = 'feedback wrong';
            playSound('wrong');
        } else if (wasCorrect) {
            fb.textContent = 'Rigtigt!';
            fb.className = 'feedback right';
            playSound('correct');
        } else {
            fb.textContent = 'Forkert!';
            fb.className = 'feedback wrong';
            playSound('wrong');
        }

        // Show correct answer and earned points
        if (q.correctText) {
            detail.innerHTML = 'Svar: <span class="feedback-correct-answer">' + q.correctText + '</span>';
        }
        const earned = q.earned || 0;
        if (earned > 0) {
            earnedEl.textContent = '+' + earned + ' pts';
            showScorePopup('+' + earned);
        } else {
            earnedEl.textContent = '';
        }

        myScore = q.scores[myName] || 0;
        myCorrectCount = wasCorrect ? (myCorrectCount + 1) : myCorrectCount;
        document.getElementById('playerScore').textContent = 'Total: ' + myScore + ' point';

        showScreen('screenPlayerFeedback');
    }
    if (data.type === 'halftime') {
        const sorted = data.scores;
        const rankIcons = ['gold', 'silver', 'bronze'];
        let html = '';
        sorted.forEach((p, i) => {
            const rankClass = i < 3 ? rankIcons[i] : '';
            const rank = i < 3 ? ['1','2','3'][i] : (i + 1);
            const color = PLAYER_COLORS[p.name] || '#2563eb';
            const highlight = p.name === myName ? 'border:2px solid #2563eb;' : '';
            html += `<div class="sb-row" style="${highlight}animation-delay:${i * 0.1}s">
                <div class="sb-rank ${rankClass}">${rank}</div>
                <div class="sb-name" style="color:${color}">${p.name}</div>
                <div><span class="sb-score">${p.score} pts</span><span class="sb-correct">${p.correct}/${Math.floor(QUESTIONS.length / 2)}</span></div>
            </div>`;
        });
        document.getElementById('playerHalftimeScoreboard').innerHTML = html;
        showScreen('screenPlayerHalftime');
    }
    if (data.type === 'scoreboard') {
        const sorted = data.scores;
        const rankIcons = ['gold', 'silver', 'bronze'];
        const rankEmoji = ['1', '2', '3'];

        // Winner banner
        if (sorted.length > 0) {
            const winner = sorted[0];
            const winnerColor = PLAYER_COLORS[winner.name] || '#fbbf24';
            document.getElementById('winnerBanner').innerHTML =
                `<span style="color:${winnerColor}">${winner.name}</span> vinder!`;
        }

        let html = '';
        sorted.forEach((p, i) => {
            const rankClass = i < 3 ? rankIcons[i] : '';
            const rank = i < 3 ? rankEmoji[i] : (i + 1);
            const color = PLAYER_COLORS[p.name] || '#2563eb';
            const highlight = p.name === myName ? 'border:2px solid #2563eb;' : '';
            const pid = 'p-answers-' + i;
            const delay = (sorted.length - 1 - i) * 0.15;
            html += `<div class="sb-row" style="${highlight}cursor:pointer;animation-delay:${delay}s;opacity:0;" onclick="document.getElementById('${pid}').style.display=document.getElementById('${pid}').style.display==='none'?'block':'none'">
                <div class="sb-rank ${rankClass}">${rank}</div>
                <div class="sb-name" style="color:${color}">${p.name}</div>
                <div><span class="sb-score">${p.score} pts</span><span class="sb-correct">${p.correct}/${QUESTIONS.length}</span></div>
            </div>
            <div id="${pid}" class="sb-answers" style="display:none;">`;
            if (p.answers) {
                p.answers.forEach((a, qi) => {
                    const icon = a.right ? '<span style="color:#16a34a">&#10003;</span>' : '<span style="color:#dc2626">&#10007;</span>';
                    html += `<div class="sb-answer">${icon} <span class="sb-aq">Q${qi+1}</span> ${a.picked}</div>`;
                });
            }
            html += `</div>`;
        });
        document.getElementById('scoreboard').innerHTML = html;
        showScreen('screenScoreboard');

        // Celebration effects
        const celebDelay = (sorted.length - 1) * 150 + 300;
        setTimeout(() => {
            playSound('fanfare');
            showConfetti();
        }, celebDelay);
    }
}

function playerAnswer(idx) {
    if (answersLocked) return;
    myAnswer = idx;

    // Highlight selected, keep all enabled for changing
    document.querySelectorAll('.answer-btn').forEach(b => b.classList.remove('selected'));
    document.getElementById('ansBtn' + idx).classList.add('selected');

    // Send to host (host handles vote changes)
    hostConn.send({ type: 'answer', option: idx });
}

// ── Auto-join from URL param ──
(function() {
    const params = new URLSearchParams(location.search);
    if (params.get('room')) {
        setTimeout(() => showJoin(), 100);
    }
})();

let myName = '';
</script>
</body>
</html>